/**
 * 
 */
package ubique.idp.batchprocessor.jprolog.dynamic.predicates;

import jp.ac.kobe_u.cs.prolog.lang.Predicate;
import jp.ac.kobe_u.cs.prolog.lang.Prolog;
import jp.ac.kobe_u.cs.prolog.lang.Term;

/**
 * Implements Prolog Subst transform rule. Based on transform rule generated by
 * Prolog Cafe.
 * 
 * @author Max Talanov
 * @see Prolog Cafe
 * @author Mutsunori Banbara (banbara@kobe-u.ac.jp)
 * @author Naoyuki Tamura (tamura@kobe-u.ac.jp)
 */
public class PredicateC45Rule extends Predicate {
	
	private static final long serialVersionUID = -3314983729900359401L;
	public Term arg1 = null;
	public Term arg2 = null;
	protected PredicateC45RuleSub first = null;
	private PredicateC45RuleSub last = null;
	private Predicate current = null;
	private int rulesNumber = 0;

	@Override
	public int arity() {
		return 2;
	}

	public PredicateC45Rule(Term a1, Term a2, Predicate cont) {
		arg1 = a1;
		arg2 = a2;
		this.cont = cont;
	}

	public PredicateC45Rule() {
	}

	@Override
	public void setArgument(Term[] args, Predicate cont) {
		arg1 = args[0];
		arg2 = args[1];
		this.cont = cont;
	}

	@Override
	public Predicate exec(Prolog engine) throws Exception {
		engine.aregs[1] = arg1;
		engine.aregs[2] = arg2;
		engine.cont = cont;
		return call(engine);
	}

	public Predicate call(Prolog engine) throws Exception {
		engine.setB0();
		if (rulesNumber < 1)
			throw new IllegalArgumentException("{No transformations specified}");
		if (rulesNumber == 1) {
			return current.exec(engine);
		} else {
			return engine.jtry(this.current, this.first);
		}
	}

	public void add(Predicate p) {
		if (this.rulesNumber < 1)
			this.current = p;
		else {
			PredicateC45RuleSub n = new PredicateC45RuleSub(p);
			if (this.last != null) this.last.setNext(n);
			this.last = n;
			if (this.first == null)
				this.first = n;
		}
		this.rulesNumber++;
	}

	@Override
	public String toString() {
		return "Predicate C4.5(" + arg1 + ", " + arg2 + ", {" +  this.current + "}  -> " + this.first + ")";
	}
}
